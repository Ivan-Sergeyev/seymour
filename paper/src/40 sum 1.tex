\section{The 1-Sum}

All matroid sums are defined on three levels: the \texttt{Matrix} level, the \texttt{StandardRepr} level, and the \texttt{Prop} (matroid) level. Let us review the distribution of responsibilities between the three levels.
\begin{leancode}
def matrixSum1 {R : Type*} [Zero R]
    {Xₗ Yₗ Xᵣ Yᵣ : Type*}
    (Aₗ : Matrix Xₗ Yₗ R) (Aᵣ : Matrix Xᵣ Yᵣ R) :
    Matrix (Xₗ ⊕ Xᵣ) (Yₗ ⊕ Yᵣ) R :=
  Matrix.fromBlocks Aₗ 0 0 Aᵣ
\end{leancode}
The same matrix in a picture:
\[
    \begin{NiceArray}{cc}[hvlines,right-margin=0.5em,left-margin=0.1em]
        A_{\ell} & 0 \\
        0 & A_{r} \\
    \end{NiceArray}
\]
The \texttt{Matrix} level defines the standard representation matrix of the output matroid as a matrix indexed by \texttt{Sum} of indexing types. This definition is so  straightforward that it would be natural to inline it into the subsequent definition. However, we retained it as a separate declaration for consistency with the 2- and 3-sums, whose matrix constructions are more elaborate.
\begin{leancode}
noncomputable def standardReprSum1
    {α : Type*} [DecidableEq α]
    {Sₗ Sᵣ : StandardRepr α Z2}
    (hXY : Disjoint Sₗ.X Sᵣ.Y)
    (hYX : Disjoint Sₗ.Y Sᵣ.X) :
    Option (StandardRepr α Z2) :=
  open scoped Classical in if
    Disjoint Sₗ.X Sᵣ.X ∧ Disjoint Sₗ.Y Sᵣ.Y
  then
    some ⟨
      Sₗ.X ∪ Sᵣ.X,
      Sₗ.Y ∪ Sᵣ.Y,
      sorry,
      (matrixSum1 Sₗ.B Sᵣ.B).toMatrixUnionUnion,
      inferInstance,
      inferInstance⟩
  else
    none
\end{leancode}
The \texttt{StandardRepr} level builds on top of the \texttt{Matrix} level.
It converts the output matrix from being indexed by \texttt{Sum} to
being index by set unions, it provides a proof that the resulting
standard representation again has row indices and column indices disjoint,
and it checks whether the operation is valid\EmDash if the preconditions
are not met, it outputs \texttt{none} instead of \texttt{some} standard representation.
\begin{leancode}
def Matroid.IsSum1of {α : Type*} [DecidableEq α]
    (M : Matroid α) (Mₗ Mᵣ : Matroid α) :
    Prop :=
  ∃ S Sₗ Sᵣ : StandardRepr α Z2,
  ∃ hXY : Disjoint Sₗ.X Sᵣ.Y,
  ∃ hYX : Disjoint Sₗ.Y Sᵣ.X,
  standardReprSum1 hXY hYX = some S
  ∧ S.toMatroid = M
  ∧ Sₗ.toMatroid = Mₗ
  ∧ Sᵣ.toMatroid = Mᵣ
\end{leancode}
The \texttt{Prop} level builds on top of the standard representation level but
talks about matroids, the combinatorial objects. On the \texttt{Prop} level, we
do not define a function; instead, we define a predicate\EmDash when $M$ is
a 1-sum of $M_{\ell}$ and $M_{r}$.

In addition to basic API about the 1-sum, we also provide
a theorem \texttt{Matroid.IsSum1of.eq\_disjointSum} that establishes
the equality between the disjoint sum (defined in Mathlib) and
the 1-sum (defined in our project) of binary matroids.

\begin{comment}
    Ivan's suggestions:
    \begin{itemize}
        \item introduction can be shortened without losing clarity, e.g., "we implement the sums of matroids in three steps"
        \item discuss design decisions: why did we implement things this way? talk about our motivation
        \item focus on results rather than process, e.g., "Proving this lemma was surprisingly difficult" $\to$ "The proof of this lemma is surprisingly long" (+ why surprisingly? what is making it long?), "could have been avoided" $\to$ "this follows from a similar result for 2-sums" (what is the message of this paragraph? should it be included?)
        \item mention why result for 1-sums was kept even though it follows from similar result for 2-sums
    \end{itemize}
\end{comment}
