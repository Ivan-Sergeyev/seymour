\section{The 1-Sum}

All matroid sums are defined on three levels:
\begin{enumerate}
    \item \texttt{Matrix} level
    \item \texttt{StandardRepr} level
    \item \texttt{Prop} level
\end{enumerate}
The \texttt{Matrix} level and \texttt{StandardRepr} level are specific to matroid \emph{compositions}
(and will have to be defined distinctly for matroid \emph{decompositions}).
The \texttt{Prop} level is direction-agnostic.
Let us review the distribution of responsibilities between the three levels.
\begin{leancode}
def matrixSum1 {R : Type*} [Zero R]
    {Xₗ Yₗ Xᵣ Yᵣ : Type*}
    (Aₗ : Matrix Xₗ Yₗ R) (Aᵣ : Matrix Xᵣ Yᵣ R) :
    Matrix (Xₗ ⊕ Xᵣ) (Yₗ ⊕ Yᵣ) R :=
  Matrix.fromBlocks Aₗ 0 0 Aᵣ
\end{leancode}
The same matrix in a picture:
\[
    \begin{NiceArray}{cc}[hvlines,right-margin=0.5em,left-margin=0.1em]
        A_{\ell} & 0 \\
        0 & A_{r} \\
    \end{NiceArray}
\]
The \texttt{Matrix} level is purely type-theoretical and it defines what will be the
standard representation matrix of the output matroid. In case of the 1-sum,
it is so easy that it could be inlined, but we keep it as a separate definition
for consistency with the 2-sum and 3-sum, whose matrix constructions are
more elaborate, as we will see in the next sections.
\begin{leancode}
noncomputable def standardReprSum1
    {α : Type*} [DecidableEq α]
    {Sₗ Sᵣ : StandardRepr α Z2}
    (hXY : Disjoint Sₗ.X Sᵣ.Y)
    (hYX : Disjoint Sₗ.Y Sᵣ.X) :
    Option (StandardRepr α Z2) :=
  open scoped Classical in if
    Disjoint Sₗ.X Sᵣ.X ∧ Disjoint Sₗ.Y Sᵣ.Y
  then
    some ⟨
      Sₗ.X ∪ Sᵣ.X,
      Sₗ.Y ∪ Sᵣ.Y,
      sorry,
      (matrixSum1 Sₗ.B Sᵣ.B).toMatrixUnionUnion,
      inferInstance,
      inferInstance⟩
  else
    none
\end{leancode}
The \texttt{StandardRepr} level builds on top of the \texttt{Matrix} level;
it converts the output matrix from being indexed by \texttt{Sum} to
being index by set unions, it provides a proof that the resulting
standard representation again has row indices and column indices disjoint,
and it checks whether the operation is valid\.---\.if the preconditions
are not met, it outputs \texttt{none} instead of \texttt{some} standard representation.
\begin{leancode}
def Matroid.Is1sumOf {α : Type*} [DecidableEq α]
    (M : Matroid α) (Mₗ Mᵣ : Matroid α) :
    Prop :=
  ∃ S Sₗ Sᵣ : StandardRepr α Z2,
  ∃ hXY : Disjoint Sₗ.X Sᵣ.Y,
  ∃ hYX : Disjoint Sₗ.Y Sᵣ.X,
  standardReprSum1 hXY hYX = some S
  ∧ S.toMatroid = M
  ∧ Sₗ.toMatroid = Mₗ
  ∧ Sᵣ.toMatroid = Mᵣ
\end{leancode}
The \texttt{Prop} level builds on top of the standard representation level but
talks about matroids, the combinatorial objects. On the \texttt{Prop} level, we
do not define a function; instead, we define a predicate\.---\.when $M$ is
a 1-sum of $M_{\ell}$ and $M_{r}$.

In addition to basic API about the 1-sum, we also provide
a theorem \texttt{Matroid.IsSum1of.eq\_disjointSum} that establishes
the equality between the disjoint sum (defined in Mathlib) and
the 1-sum (defined in our project) of binary matroids.

\begin{comment}
    Ivan's suggestions:
    \begin{itemize}
        \item introduction can be shortened without losing clarity, e.g., "we implement the sums of matroids in three steps"
        \item discuss design decisions: why did we implement things this way? talk about our motivation
        \item focus on results rather than process, e.g., "Proving this lemma was surprisingly difficult" $\to$ "The proof of this lemma is surprisingly long" (+ why surprisingly? what is making it long?), "could have been avoided" $\to$ "this follows from a similar result for 2-sums" (what is the message of this paragraph? should it be included?)
        \item mention why result for 1-sums was kept even though it follows from similar result for 2-sums
    \end{itemize}
\end{comment}
