\section{Suggestions for Lean's Ecosystem}

When working on the project, our overall experience of working with Lean, Mathlib, and Aesop was very positive. Nevertheless, in our opinion, certain things could be made even better, and we share our improvement suggestions below.

\subsection{Suggestions for Lean}

% @suggestion: use \paragraph{} to begin each point for better readability?

% `Recall`-ing Structures
The \texttt{recall} command is really helpful for presentation and believability of our trusted code. Unfortunately, it currently does not support structures, which is a significant limitation. For example, suppose we want to recall
\begin{leancode}
structure StandardRepr (α R : Type*)
    [DecidableEq α] where
  X : Set α
  Y : Set α
  hXY : X ⫗ Y
  B : Matrix X Y R
  decmemX : ∀ a, Decidable (a ∈ X)
  decmemY : ∀ a, Decidable (a ∈ Y)
\end{leancode}
Currently, we have to separately \texttt{recall} every field of the structure:
\begin{leancode}
recall StandardRepr.X {α R : Type*}
  [DecidableEq α] :
  StandardRepr α R → Set α
recall StandardRepr.Y {α R : Type*}
  [DecidableEq α] :
  StandardRepr α R → Set α
recall StandardRepr.B {α R : Type*}
  [DecidableEq α] (S : StandardRepr α R) :
  Matrix S.X S.Y R
recall StandardRepr.hXY {α R : Type*}
  [DecidableEq α] (S : StandardRepr α R) :
  Disjoint S.X S.Y
recall StandardRepr.decmemX {α R : Type*}
  [DecidableEq α] (S : StandardRepr α R) :
  ∀ a, Decidable (a ∈ S.X)
recall StandardRepr.decmemY {α R : Type*}
  [DecidableEq α] (S : StandardRepr α R) :
  ∀ a, Decidable (a ∈ S.Y)
\end{leancode}
This code contains a lot of repetition and can be difficult to read and compare to the original declaration. Moreover, it does not ensure that all fields of the structure are listed, so we additionally check the constructor using \texttt{\#guard\_msgs}:
\begin{leancode}
/--
info: StandardRep.mk.{u_1, u_2}
  {α : Type u_1} {R : Type u_2} [DecidableEq α]
  (X Y : Set α) (hXY : X ⫗ Y)
  (B : Matrix (↑X) (↑Y) R)
  (decmemX : (a : α) → Decidable (a ∈ X))
  (decmemY : (a : α) → Decidable (a ∈ Y)) :
  StandardRepr α R
-/
#guard_msgs in
#check StandardRepr.mk
\end{leancode}
Without this additional check, it would be possible to cheat. One could maliciously add a field claiming that $1 + 1 = 3$ to \texttt{StandardRepr}, not recall it in the presentation file, and then use it to prove any result without having to capture its mathematical essence. Although the approach of recalling all fields of a structure and then checking the constructor is sufficient for our presentation file, being able to \texttt{recall} the structure directly would make it easier to write complete and believable trusted code.

% Dependencies
When refactoring our library, we found it tedious to identify definitions and lemmas that are unused and can be safely pruned. In many cases, we could identify them using project-wide search or the ``go to reference'' command in VS Code, but we had to do it by hand in every instance, and we had to be particularly careful whenever dot notation was used. Moreover, for lemmas with the \texttt{@[simp]} attribute, neither of the two approaches could be used to find the \texttt{simp} calls using such lemmas. Ultimately, the only way to know for sure if something was used or not was to try removing it and recompiling the entire project, which could take a long time especially if the change affected a file close to the root of the dependency graph. It would be ideal to have a tool that could show which definitions and lemmas are used in the implementation of each statement and proof, perhaps in the form of a dependency graph similar to the one generated by \texttt{leanblueprint}. This would not only help identify code that is never used, but also give a clear and precise overview of all the dependencies of the final results based on the implementation itself. Note that \texttt{leanblueprint} would not suffice, as it creates the dependency graph based on the user-specified dependencies in the latex blueprint and not on the Lean implementation itself.

% Inferring Fintype from Finite
Although Lean is capable of automatically inferring type class instances, some are deliberately excluded. One example is that the \texttt{Fintype} instance is not automatically inferred from the \texttt{Finite} instance when one is present: the \texttt{Fintype} instance carries \emph{computable} data enumerating a type, and instances that would construct non-computable data are generally avoided. It would be nice if such cases were handled automatically, as it can be non-trivial to provide the correct instance by hand, for example, if the ``missing'' instance is required deep in an instance synthesis search. 

% Delaborators
Our next suggestion concerns \emph{delaboration} in Lean, which is the inverse of elaboration. The process of elaboration takes user-facing syntax, which may be ambiguous in terms of, for example, the used notation, inferred types, and implicit arguments, and transforms it into Lean's core type theory, producing a typed expression. For instance, the type of \texttt{$\pi$ + 2} can be different depending on the meaning of $\pi$ (which could be the transcendental real number close to 3 or the prime counting function), $2$ (a numeric literal integer, a real number, or even the set $\{\{\},\{\{\}\}\}$), and $+$ (integer addition, real addition, or even direct sum of groups). The elaborator assigns Lean constants and variables to these syntactic objects using the current context: if a larger expression is \texttt{Real.sin ($\pi$ + 2)}, then we expect a real number, which allows us to infer the meaning of all the syntactic objects. In contrast to elaboration, delaboration transforms a parsed tree back into a syntactic representation and is used as part of the interactive development process, as opposed to program execution. It is not to be confused with \emph{printing} a value, or \texttt{ToRepr} in Lean, which transforms \emph{data} into a human-readable representation. A \emph{delaborator} is then meta-programming code that represents a particular class of expressions in a more readable form.

% Delaborators and `Subtype`-s
While working on our project, we % implemented many custom delaborators, for instance, to improve readability of complex matrix expressions, and in the process we
discovered several shortcomings of the current delaborator. First, \texttt{Subtype} has a delaborator producing \texttt{⟨i, hi⟩}, which is more readable than the default \texttt{(Subtype.mk i hi)}, especially when there are multiple occurrences within a complex expression. However, this delaborator is incompatible with the \texttt{pp.structureInstances=false} setting, which disables the pretty printing of structure instances and helps make the output cleaner. It would be nice to be able to simultaneously use explicit constructors for some types and specialized delaborators for other types.

% Delaborators and dot notation
Another limitation of the current delaborator is its handling of dot notation. For example, given a list \texttt{l}, its length \texttt{List.length l} is displayed in the Infoview using dot notation as \texttt{l.length}. However, the delaborator does not always take advantage of the dot notation and sometimes displays the longer version instead, in particular for \texttt{private} declarations (unlike for public declarations) and for \texttt{Function.something} or \texttt{Subtype.something} declarations. The way we addressed this in our implementation was by implementing custom delaborators, such as
\begin{leancode}
@[app_unexpander Matrix.toCanonicalSigning]
private def Matrix.toCanonicalSigning_unexpand :
    Lean.PrettyPrinter.Unexpander
  | `($_ $Q) => `($(Q).$(Lean.mkIdent
        `toCanonicalSigning))
  | _ => throw ()
\end{leancode}
It would be ideal if delaboration consistently took advantage of dot notation out of the box, as implementing unexpanders manually clutters the code and is prone to errors.
\todo[inline]{@Martin: As a result of our RFC, private declarations have been addressed...}
% Martin: Dot notation for private definitions has been fixed today.
% https://github.com/leanprover/lean4/pull/10122
% Remove from here?
% Ivan: yes; or leave a mention, if the change was suggested or influenced by us
