\section{Introduction}

% \subsection{Context}
Seymour's regular matroid decomposition theorem is a hallmark structural result in matroid theory \cite{Oxley2011,Truemper2016,Geelen2005,Kingan2015}. It states that, on the one hand, any 1-, 2-, and 3-sum of two regular matroids is regular, and on the other hand, any regular matroid can be decomposed into matroids that are graphic, cographic, or isomorphic to $R_{10}$ by repeated 1-, 2-, and 3-sum decompositions.
% idea for another sentence: It was originally proved by Seymour in <reference>, its proof was more recently presented in <references>, and alternative proofs of parts of the theorem were given by <references>.

% \subsection{Motivation}
The interest in matroids comes from the fact that they capture and generalize many mathematical structures and properties, such as linear independence (captured by vector matroids), graphs (graphic matroids), and extensions of fields (algebraic matroids). Another advantage of matroids is that they admit a relatively short definition, making them amenable to formalization. As for Seymour's theorem, it not only presents a structural characterization of the class of regular matroids, but also leads to several important applications, such as polynomial algorithms for testing if a matroid is binary and for testing if a matrix is totally unimodular. Additionally, Seymour's theorem can offer a structural approach for solving certain combinatorial optimization problems, for example, it leads to the characterization and efficient algorithms for the cycle polytope.

% \subsection{Challenges}
Formalization of results about matroids faces several challenges. One of them is that the support for them is limited. In Mathlib, only selected basic definitions for matroids are implemented, such as maps, duals, and minors. However, many other fundamental notions are not yet implemented, including representability and regularity, the splitter theorem and the separation algorithm. Part of the difficulty stems from the fact that classically, matroids are defined only in the finite case (i.e., when the ground set and the rank are finite), while Mathlib implements matroids more generally, allowing them to be infinite and to have infinite rank. Additionally, the proofs presented in the existing literature require substantial additional work to make them easily amenable to formalization.

% \subsection{Project Goals}
The goal of our work was to develop a general and reusable library proving a result that is at least as strong as the forward (composition) direction of classical Seymour's theorem (i.e., stated for finite matroids). Moreover, our aim was to make our library modular and extensible by ensuring compatibility with Mathlib and its implementation of matroids. Last but not least, we aimed to capture the final results in just a few theorems, which can be easily understood and matched with the corresponding theoretical results.

% \subsection{Compromises}
To achieve our goals, we made the following compromises. First, we focused on the implementation of the proof of the composition direction, while only stating the decomposition direction. Second, we assumed finiteness where it would simplify proofs, while making sure that the final results held for finite matroids (in fact, they hold for matroids with potentially infinite ground set and finite rank). Finally, we tailored our implementation specifically to Seymour's theorem, avoiding introducing additional matroid notions if possible.

% \subsection{Contribution}
Our project makes the following contributions:
\begin{itemize}
    \item Formalized definition and selected properties of totally unimodular matrices, some of which were added to Mathlib.
    \item Implemented definitions and formally proved selected results about vector matroids, their standard representations, regular matroids, and 1-, 2-, and 3-sums of matrices and vector matroids given by their standard representations.
    \item Implemented a formally verified proof of the composition direction of Seymour's theorem, i.e., that any 1-, 2-, and 3-sum of two regular matroids is regular, in the case where the matroids may have infinite ground sets and have finite rank.
    \item Stated the decomposition direction of Seymour's theorem, i.e., that any regular matroid of finite rank can be decomposed into matroids that are graphic, cographic, or isomorphic to $R_{10}$ by repeated 1-, 2-, and 3-sum decompositions.
\end{itemize}

% \subsection{Implementation}
Our formalization\footnote{\url{https://github.com/Ivan-Sergeyev/seymour}} is conceptually split into two parts: ``implementation'' and ``presentation''. The former is contained in the \texttt{Seymour} folder and encompasses all definitions and lemmas used to obtain our results. The latter is contained in the \texttt{Seymour.lean} file, which repeats selected definitions and theorems comprising the key final results of our contribution. Every definition in the ``presentation'' file is checked to be definitionally equal to its counterpart from the ``implementation'' using the \texttt{recall} or the \texttt{example} command. Similarly, we \texttt{recall} every theorem presented here and then use the \texttt{\#guard\_msgs in \#print axioms} command to check that the implementation of its proof (including the entire dependency tree) depends only on the three axioms \texttt{[propext, Classical.choice, Quot.sound]}, which are standard for Lean projects that use classical logic.

We refer to the statements of the final results and the definitions they (transitively) depend on as \emph{trusted code}. The \texttt{Seymour.lean} file repeats all nontrivial trusted code, so that the reader can believe our results \cite{Pollack1997} without having to examine the entire implementation, assuming that the reader also uses the Lean compiler to check that all proofs are correct. Note that basic definitions from Lean and Mathlib are part of the trusted code, but are not repeated in \texttt{Seymour.lean}, and we let the reader decide whether to blindly trust them or read them as well.

While working on our project, we leveraged the LeanBlueprint\footnote{\url{https://github.com/PatrickMassot/leanblueprint}} tool to help guide our formalization efforts. In particular, we used it to create theoretical blueprints and dependency graphs, which allowed us to get a clearer overview of the results we were formalizing, as well as their dependencies. In our workflow, we first created a write-up encompassing the classical results from \cite{Truemper2016}. Based on this write-up, we developed a self-contained theoretical blueprint for our formalization by filling in gaps, fleshing out technical details, and sometimes re-working certain proofs. We followed this blueprint during the development of our library, keeping it up to date and turning it into documentation of our code.

We use Lean version 4.18.0 and we import Mathlib library revision aa936c3 (dated 2025-04-01).

We made the code snippets in this paper as faithful to the content of the repository as possible, though we made some omissions. In particular, proofs inside definitions were replaced by the \leaninline{sorry} keyword in the paper, while the repository contains the complete implementation.