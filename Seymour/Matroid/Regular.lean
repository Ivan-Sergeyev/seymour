import Seymour.Matrix.LinearIndependence
import Seymour.Matrix.TotalUnimodularity
import Seymour.Matroid.StandardRepr


-- ## Definition of regularity via TU full matrix representation

/-- Matroid is regular iff it can be represented as a vector matroid given by a rational TU matrix. -/
def Matroid.IsRegular {α : Type} (M : Matroid α) : Prop :=
  ∃ X Y : Set α, ∃ A : Matrix X Y ℚ, M = A.toMatroid ∧ A.IsTotallyUnimodular

/-- Applying an equivalence mapping foward and backwards does not change the matroid. -/
private lemma Matroid.mapEquiv_symm_eq {α β : Type} (M : Matroid α) (e : α ≃ β) :
    M = (M.mapEquiv e).mapEquiv e.symm := by
  aesop

/-- Equivalence mapping preserves regularity of matroids. -/
@[simp]
lemma Matroid.isRegular_mapEquiv_iff {α β : Type} (M : Matroid α) (e : α ≃ β) :
    (M.mapEquiv e).IsRegular ↔ M.IsRegular := by
  constructor <;> intro ⟨X, Y, A, hAM, hA⟩
  on_goal 1 => let f := e.symm
  on_goal 2 => let f := e
  all_goals
    use f '' X, f '' Y, A.submatrix (f.image X).symm (f.image Y).symm
    rw [←A.toMatroid_mapEquiv_eq f, ←hAM]
    constructor
    · simp [f, ←M.mapEquiv_symm_eq e]
    · exact hA.submatrix _ _

/-- Every regular matroid can be generated by a standard representation matrix over `Z2`. -/
lemma Matroid.IsRegular.hasStandardReprZ2 {α : Type} {M : Matroid α} (hM : M.IsRegular) :
    ∃ S : StandardRepr α Z2, M = S.toMatroid := by
  obtain ⟨X, Y, A, rfl, hA⟩ := hM
  have := Classical.typeDecidableEq X
  have := Classical.typeDecidableEq Y
  have hA' := hA.toMatroid_eq_support_toMatroid.symm
  obtain ⟨B, hB⟩ := A.toMatroid.exists_isBase
  obtain ⟨S, hSV⟩ := A.support.fromFullToStandardRepr_exists (hA' ▸ hB)
  use S, hA' ▸ hSV


-- ## Equivalent definition of regularity via Z2 standard matrix representation with TU signing

/-- `LinearOrderedRing`-valued matrix `A` is a signing of `U` (matrix of the same size but different type) iff `A` has
    the same as entries in `U` on respective positions up to signs. -/
def Matrix.IsSigningOf {X Y R : Type} [LinearOrderedRing R] (A : Matrix X Y R) (U : Matrix X Y Z2) : Prop :=
  ∀ i : X, ∀ j : Y, |A i j| = (U i j).val

/-- Rational matrix `A` is a TU signing of `U` (matrix of the same size but different type) iff `A` is TU and its entries are
    the same as entries in `U` on respective positions up to signs.
    Do not ask `U.IsTotallyUnimodular` ... see `Matrix.overZ2_isTotallyUnimodular` for example! -/
def Matrix.IsTuSigningOf {X Y : Type} (A : Matrix X Y ℚ) (U : Matrix X Y Z2) : Prop :=
  (∀ i : X, ∀ j : Y, |A i j| = (U i j).val) ∧ A.IsTotallyUnimodular

/-- Matrix `U` has a TU signing iff there is a rational TU matrix whose entries are the same as those in `U` up to signs. -/
def Matrix.HasTuSigning {X Y : Type} (U : Matrix X Y Z2) : Prop :=
  ∃ A : Matrix X Y ℚ, A.IsTuSigningOf U

/-- A TU matrix is a TU signing of its support matrix. -/
private lemma Matrix.IsTotallyUnimodular.isTuSigningOf_support {X Y : Type} {A : Matrix X Y ℚ} (hA : A.IsTotallyUnimodular) :
    A.IsTuSigningOf A.support := by
  constructor
  · intro i j
    obtain ⟨s, hs⟩ := hA.apply i j
    rw [Matrix.support, Matrix.of_apply, ZMod.natCast_val, ←hs]
    cases s <;> rfl
  · exact hA

/-- If `A` is a signing of `U` and only has `{0, ±1}` entries, then the support matrix of `A` is `U`. -/
private lemma Matrix.isSigningOf_pnz_eq_support {X Y : Type} {A : Matrix X Y ℚ} {U : Matrix X Y Z2}
    (hAU : A.IsSigningOf U) (hA : ∀ i : X, ∀ j : Y, A i j ∈ Set.range SignType.cast):
    A.support = U := by
  ext i j
  rw [Matrix.support, Matrix.of_apply]
  specialize hAU i j
  obtain ⟨s, hs⟩:=  hA i j
  if h0 : U i j = 0 then
    simp only [h0, ZMod.val_zero, CharP.cast_eq_zero, abs_eq_zero] at hAU
    simp [hAU, h0]
  else
    rw [Z2_eq_1_of_ne_0 h0] at hAU ⊢
    have hAij : A i j ≠ 0 :=  fun h => by simp [h, ZMod.val_one_eq_one_mod] at hAU
    simp [hAij]

/-- Vector matroid given by full representation matrix over `Z2` is regular if the matrix has a TU signing. -/
private lemma Matrix.toMatroid_isRegular_if_hasTuSigning {α : Type} {X Y : Set α} [DecidableEq X] [DecidableEq Y]
    (A : Matrix X Y Z2) :
    A.HasTuSigning → A.toMatroid.IsRegular := by
  intro ⟨A', hA'A, hA'⟩
  use X, Y, A', ((Matrix.isSigningOf_pnz_eq_support hA'A hA'.apply) ▸ hA'.toMatroid_eq_support_toMatroid).symm, hA'

/-- Vector matroid given by standard representation matrix over `Z2` is regular iff the matrix has a TU signing. -/
lemma StandardRepr.toMatroid_isRegular_iff_hasTuSigning {α : Type} (S : StandardRepr α Z2) [Fintype S.Y] :
    S.toMatroid.IsRegular ↔ S.A.HasTuSigning := by
  constructor
  · intro ⟨X', Y', A', hA', hA'tu⟩
    have hY := S.toMatroid_isBase_Y
    -- have : Fintype Y' := sorry
    -- obtain ⟨X, Y, hXY, B, _, _⟩ := S
    -- dsimp only at hY ⊢
    -- obtain ⟨S', hXX, hSA, hB'⟩ := A.toMatroid.exists_standardRepr_isBase_isTotallyUnimodular (hAB ▸ hX) hA
    -- have hBB := support_eq_support_of_same_matroid_same_X (hSA.trans hAB) hXX
    -- simp only [Matrix.support_Z2] at hBB
    -- have hYY : S'.Y = Y := right_eq_right_of_union_eq_union hXX S'.hXY hXY (congr_arg Matroid.E (hSA.trans hAB))
    -- use hXX ▸ hYY ▸ S'.B
    -- have := hB'.isTuSigningOf_support
    -- cc
    sorry
  · intro ⟨A', hA'A, hA'⟩
    have : DecidableEq (S.X ∪ S.Y).Elem := Classical.typeDecidableEq (S.X ∪ S.Y).Elem
    apply S.toFullRepr.toMatroid_isRegular_if_hasTuSigning
    use (A'.toStandardRepr S.hXY).toFullRepr
    constructor
    · intro i j
      unfold StandardRepr.toFullRepr
      cases hi : i.toSum with
      | inl x => convert hA'A x j <;> rw [Function.comp_apply, hi] <;> rfl
      | inr y =>
          simp only [Function.comp_apply, hi, Matrix.fromRows_apply_inr, ZMod.natCast_val]
          if hy : y = j then
            rewrite [hy, Matrix.one_apply_eq, Matrix.one_apply_eq]
            rfl
          else
            rewrite [Matrix.one_apply_ne hy, Matrix.one_apply_ne hy]
            rfl
    · exact StandardRepr.toFullRepr_isTotallyUnimodular hA'


-- ## Dual of regular matroid

open scoped Matrix

lemma Matroid.IsRegular.dual {α : Type} {M : Matroid α} (hM : M.IsRegular) : M✶.IsRegular := by
  obtain ⟨S, rfl⟩ := hM.hasStandardReprZ2
  have hSX : Fintype S.X := sorry
  have : Fintype S.Y := sorry
  have : Fintype S✶.Y := hSX
  rw [←S.dual_toMatroid]
  rw [StandardRepr.toMatroid_isRegular_iff_hasTuSigning] at hM ⊢
  obtain ⟨A, hAS, hA⟩ := hM
  exact ⟨-Aᵀ, by simp_all [StandardRepr.dual, Matrix.IsSigningOf], hA.transpose.neg⟩

lemma Matroid.IsRegular.of_dual {α : Type} {M : Matroid α} (hM : M✶.IsRegular) : M.IsRegular :=
  M.dual_dual ▸ hM.dual
